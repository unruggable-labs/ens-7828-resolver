import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import https from "https";
import { MAJOR_CHAINS, MAJOR_L2_CHAIN_IDS } from "./chains.ts";
import {
  ChainInfo,
  ChainListInfoSchema,
  ChainListSchema,
} from "../src/types.ts";
import { MANUAL_CHAINS } from "./chains.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const EIP155 = "eip155";

async function fetchChainData(
  chainId: number
): Promise<ChainListSchema | null> {
  return new Promise((resolve, _) => {
    const url = `https://raw.githubusercontent.com/ethereum-lists/chains/master/_data/chains/eip155-${chainId}.json`;

    https
      .get(url, (res) => {
        let data = "";

        res.on("data", (chunk) => {
          data += chunk;
        });

        res.on("end", () => {
          if (res.statusCode === 200) {
            try {
              const json = JSON.parse(data);
              const chainData = ChainListInfoSchema.parse(json);
              resolve(chainData);
            } catch (error) {
              console.log(
                `Failed to parse or validate JSON for chain ${chainId}: ${error}`
              );
              resolve(null);
            }
          } else {
            console.log(
              `Chain ${chainId} not found in ethereum-lists (${res.statusCode})`
            );
            resolve(null);
          }
        });
      })
      .on("error", (error) => {
        console.log(`Error fetching chain ${chainId}: ${error.message}`);
        resolve(null);
      });
  });
}

async function fetchAllChainData(): Promise<ChainListSchema[]> {
  console.log("Fetching chain data from ethereum-lists/chains repository...");

  const chainIds = MAJOR_CHAINS.map((chain) => chain.chainId);

  const promises = chainIds.map(async (chainId) => {
    const chainData = await fetchChainData(chainId);
    if (chainData) {
      console.log(`‚úÖ Found: ${chainData.name} (${chainId})`);
      return chainData;
    } else {
      console.log(`‚ùå Not found: Chain ${chainId}`);
      return null;
    }
  });

  const results = await Promise.all(promises);
  return results.filter((chain): chain is ChainListSchema => chain !== null);
}

// For EVM chains, coinType is derived using ENSIP-11 (0x80000000 + chainId)
// For non-EVM chains, coinType is the SLIP-44 value
function deriveCoinType(chainId: number): number {
  // ENSIP-11 derivation: coinType = (chainId | 0x80000000) >>> 0
  return (chainId | 0x80000000) >>> 0;
}

/**
 * Processes an array of ChainInfo objects and returns an array of ChainInfo objects with standardized fields.
 *
 * - For each chain, determines the correct coinType value:
 *   - For EVM chains: uses ENSIP-11 (0x80000000 + chainId)
 *   - For non-EVM chains: uses the SLIP-44 value
 *   - Prefers the value from MAJOR_CHAINS if present (BIP-44/SLIP-44 standard or curated value).
 *   - Otherwise, uses the coinType value from the fetched chain data if available.
 *   - If neither is available, derives a coinType value using ENSIP-11 (chainId | 0x80000000).
 *
 * @param chains Array of ChainInfo objects fetched from ethereum-lists/chains and/or curated list
 * @returns Array of ChainInfo objects with standardized coinType values
 */
function processChainData(chains: ChainListSchema[]): ChainInfo[] {
  return chains.map((chain) => {
    // Prefer slip44 if present, otherwise derive
    const coinType: number =
      (typeof chain.slip44 === "number" ? chain.slip44 : undefined) ??
      (typeof chain.chainId === "number" ? deriveCoinType(chain.chainId) : 0);

    return {
      chainId: chain.chainId,
      shortName: chain.shortName,
      name: chain.name,
      coinType: coinType,
      namespace: EIP155,
      reference: chain.chainId.toString(),
    };
  });
}

function generateChainMapping(chains: ChainInfo[]): string {
  const byChainId: Record<number, ChainInfo> = {};
  const byShortName: Record<string, ChainInfo> = {};
  const byNameSpace: Record<string, ChainInfo> = {};
  const manualChains: Record<string, ChainInfo> = {};

  MANUAL_CHAINS.forEach((chain) => {
    manualChains[chain.shortName] = chain;
    if (chain.reference) {
      byNameSpace[chain?.reference] = chain;
    }
  });

  chains.forEach((chain) => {
    byChainId[chain.chainId] = chain;
    byShortName[chain.shortName] = chain;
  });

  const chainData = JSON.stringify(chains, null, 2);
  const byChainIdData = JSON.stringify(byChainId, null, 2);
  const byShortNameData = JSON.stringify(byShortName, null, 2);
  const byNameSpaceData = JSON.stringify(byNameSpace, null, 2);
  const manualChainsMap = JSON.stringify(manualChains, null, 2);

  return `
// Auto-generated by scripts/buildChainMap.ts
// Source: ethereum-lists/chains repository + BIP-44 constants
// Major chains curated based on market cap, TVL, and ecosystem importance

import { ChainInfo } from './types.js';

export const chains: Array<ChainInfo> = ${chainData};

export const byChainId: Record<string, ChainInfo> = ${byChainIdData};

export const byShortName: Record<string, ChainInfo> = ${byShortNameData};

export const byNameSpaceReference: Record<string, ChainInfo> = ${byNameSpaceData};

export const MANUAL_CHAINS: Record<string, ChainInfo> = ${manualChainsMap};
`;
}

async function main() {
  try {
    console.log(
      `üìä Fetching Chain data. Targeting ${MAJOR_CHAINS.length} major chains`
    );

    const chainData = await fetchAllChainData();

    console.log(
      `\nüìä Found ${chainData.length} chains out of ${MAJOR_CHAINS.length} requested`
    );

    console.log("\nüîÑ Processing chain data...");
    const processedChains = processChainData(chainData);

    // Convert manual chains and add them
    const allChains = [...processedChains, ...MANUAL_CHAINS];

    console.log("\nüìù Generating chain mapping...");
    const mappingContent = generateChainMapping(allChains);

    const outputPath = path.join(__dirname, "..", "src", "chain-mapping.ts");
    fs.writeFileSync(outputPath, mappingContent);

    console.log(`\n‚úÖ Chain mapping generated at: ${outputPath}`);
    console.log(`üìà Processed ${allChains.length} chains`);

    const l2s = processedChains.filter(
      (c) =>
        typeof c.chainId === "number" && MAJOR_L2_CHAIN_IDS.includes(c.chainId)
    );

    console.log("\nüéØ Major L2s included:");
    l2s.forEach((chain) => {
      console.log(`   - ${chain.name} (${chain.chainId})`);
    });
  } catch (error) {
    console.error("‚ùå Error building chain map:", error);
    process.exit(1);
  }
}

main();
